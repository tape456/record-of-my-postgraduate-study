# python解释器原理

1.启动python解释器,python解释器相当于一个文本编辑器 00000
2.打开文件,读出文件的内容,pthon解释器相当于一个文本编辑器,->发生了字符编码,name='nick'

3. python解释器解释 name='nick’,然后才有语法的概念 -->发生了字符编码 00000

0000010101001001001(硬盘中)-->name='nick(内存)->开辟一块内存空间 -->000010101010



字符编码发生在哪三个阶段

1.存   内存到硬盘

2.取   硬盘到内存

3.python3解释器解释

这时候问题出现了，精通18国语言的小周同学谦虚的用8国语言写了一篇文档，那么这篇文档，按照哪国的标准，都会出现乱码（因为此刻的各种标准都只是规定了自己国家的文字在内的字符跟数字的对应关系，如果单纯采用一种国家的编码格式，那么其余国家语言的文字在解析时就会出现乱码）。所以迫切需要一个世界的标准（能包含全世界的语言）于是Unicode应运而生（韩国人表示不服，然后没有什么卵用）。



ascii用1个字节（8位二进制）代表一个字符；Unicode常用2个字节（16位二进制）代表一个字符，生僻字需要用4个字节。



这时候乱码问题消失了，所有的文档我们都使用但是新问题出现了，如果我们的文档通篇都是英文，你用Unicode会比ascii耗费多一倍的空间，在存储和传输上十分的低效。

本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8（Unicode Transformation Format-8）编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：



| 字符 |  ASCII   |      Unicode      |           UTF-8            |
| :--: | :------: | :---------------: | :------------------------: |
|  A   | 01000001 | 00000000 01000001 |          01000001          |
|  中  |    x     | 01001110 00101101 | 11100100 10111000 10101101 |



utf-8的出现只是为了节省空间，把这个00000000 01000001改成01000001



## 5.4 内存为什么不用UTF-8呢？

说了那么一大堆，那为什么内存用Unicode，而不直接使用UTF-8呢？这样不就可以直接把代码从内存直接丢入硬盘了吗？出现这个问题的原因是硬盘中还躺了其他国家的代码，各个国家的代码的二进制还需要运行在计算机上使用，因此内存中必须使用Unicode的编码，因为Unicode能和硬盘中其他国家的二进制中的代码进行转换，但是UTF-8只是简化了代码的存储，它并不能与其他国家硬盘中的代码进行关系转换。总而言之只有Unicode编码才能运行其他国家硬盘中的代码，而UTF-8的代码无法进行该操作。

内存中还使用Unicode编码，是因为历史遗留问题造成的，但是因为现在写代码使用的都是UTF-8代码，所以以后内存中的代码都将变成UTF-8代码，并且以前遗留的各个国家的代码都将被淘汰，所以未来内存中使用的编码也将使用UTF-8编码替代Unicode编码。





内存中的编码格式统一都是unicode

1. 在内存中写的所有字符，一视同仁，都是Unicode编码，比如我们打开编辑器，输入一个“你”，我们并不能说“你”就是一个汉字，此时它仅仅只是一个符号，该符号可能很多国家都在使用，根据我们使用的输入法不同这个字的样式可能也不太一样。只有在我们往硬盘保存或者基于网络传输时，才能确定”你“到底是一个汉字，还是一个日本字，这就是Unicode转换成其他编码格式的过程了。简而言之，就是内存中固定使用的就是Uncidoe编码，我们唯一能改变的就是存储到硬盘时使用的编码。



从内存到硬盘 的过程，即unicode-->gbk，称为编码 encode

从硬盘到内存 的过程，即gbk-->unicode 称为解码 decode 



#coding:gbk

x='上'

x=u'上'



## python3（掌握）















解释定义变量的语法,会新开辟一块内存空间放入这个变量,然后假设这个变量在python3中以utf-8的,被python3解释后再内存中会变成x=000001101010`.理论上`print(x)形式存储,如字符`'x=’中’`相当于输出~000001101010,但是这个`000001101010`对于程序员来讲看不懂,所以python3创始人龟叔做了这个操作-把~000001101010`编码按终端的编码格式输出编码后的结果,如`上”.如果终端的编码为gbk,终端无法识别~000001101010`,所以新开辟空间放入变量的时候,就用umicode转换,则终端无论是什么形式的编码格式,都能够识别并打印.



## python3解释器解释

在python3解释器解释的时候， 







